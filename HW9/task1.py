# Даны значения величины заработной платы заемщиков банка (zp)
# и значения их поведенческого кредитного скоринга (ks):
# zp = [35, 45, 190, 200, 40, 70, 54, 150, 120, 110],
# ks = [401, 574, 874, 919, 459, 739, 653, 902, 746, 832].
# Используя математические операции, посчитать коэффициенты линейной регрессии,
# приняв за X заработную плату (то есть, zp - признак),
# а за y - значения скорингового балла (то есть, ks - целевая переменная).

import numpy as np

zp = np.array([35, 45, 190, 200, 40, 70, 54, 150, 120, 110]) # независимая переменная х
ks = np.array([401, 574, 874, 919, 459, 739, 653, 902, 746, 832]) # зависимая переменная y

n = len(zp) # 10

#-----------------------------РЕШЕНИЕ С ПОМОЩЬЮ ФОРМУЛ-----------------------------------------------

# первый способ
b1_first = (n * np.sum(ks * zp) - np.sum(zp) * np.sum(ks)) / (n * np.sum(zp**2) - np.sum(zp)**2)
print(f'b1 первым способом = {b1_first}') # 2.6205388824027653

# второй способ
b1_second = (np.mean(zp * ks) - np.mean(zp) * np.mean(ks)) / (np.mean(zp**2) - np.mean(zp)**2)
print(f'b1 вторым способом = {b1_second}') # 2.620538882402765

b0 = np.mean(ks) - b1_first * np.mean(zp)
print(f'b0 = {b0}') # 444.17735732435955

# получили модель: ks = 444.18 + 2.62 * zp

#-----------------------------РЕШЕНИЕ МАТРИЧНЫМ МЕТОДОМ-----------------------------------------------

# создаём вектор-столбцы
X = zp.reshape((len(zp), 1))
Y = ks.reshape((len(ks), 1))

X_matrix = np.hstack([np.ones((len(X), 1)), X]) # для модели с интерсептом

B = np.dot(np.linalg.inv(np.dot(X_matrix.T, X_matrix)), X_matrix.T @ Y)
print(B)
# [[444.17735732]
#  [  2.62053888]]

BwoIntercept = np.dot(np.linalg.inv(np.dot(X.T, X)), X.T @ Y) # для модели без интерсепта
print(BwoIntercept)
# [[5.88982042]]

# получили модель с интерсептом: ks = 444.18 + 2.62 * zp
# либо модель без интерсепта: ks = 5.8898 * zp

#-----------------------------ПРОВЕРКА С ПОМОЩЬЮ ФУНКЦИИ----------------------------------------------

from sklearn.linear_model import LinearRegression
model = LinearRegression()
zpVertical = zp.reshape(-1, 1)

# подбор коэффициентов, расчёт интерсепта, расчёт коэффициента B1
regres = model.fit(zpVertical, ks)
intercept = regres.intercept_ # 444.17735732435943
coefficientArray = regres.coef_ # <class 'numpy.ndarray'> [2.62053888]
coefficient = coefficientArray[0] # 2.6205388824027667

# получили модель: ks = 444.18 + 2.62 * zp